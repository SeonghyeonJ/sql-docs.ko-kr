---
title: 메모리 액세스에 최적화된 테이블의 복원 및 복구 | Microsoft 문서
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 294975b7-e7d1-491b-b66a-fdb1100d2acc
author: CarlRabeler
ms.author: carlrab
manager: craigg
ms.openlocfilehash: 9560249e07cbd360914b5dab21eb68dc8e7f013f
ms.sourcegitcommit: f7fced330b64d6616aeb8766747295807c92dd41
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/23/2019
ms.locfileid: "62467247"
---
# <a name="restore-and-recovery-of-memory-optimized-tables"></a>메모리 액세스에 최적화된 테이블의 복원 및 복구
  메모리 최적화 테이블이 있는 데이터베이스를 복구하거나 복원하기 위한 기본 메커니즘은 디스크 기반 테이블만 있는 데이터베이스와 비슷합니다. 하지만 디스크 기반 테이블과 달리, 메모리 최적화 테이블은 먼저 메모리에 로드해야만 사용자가 데이터베이스에 액세스할 수 있습니다. 따라서 데이터베이스 복구에 새로운 단계가 추가됩니다. 수정된 데이터 복구 단계는 다음과 같이 변경됩니다.  
  
 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 가 다시 시작되면 각 데이터베이스가 다음 세 단계로 구성된 복구 단계를 거칩니다.  
  
1.  분석 단계. 이 단계 중에는 커밋된 트랜잭션과 커밋되지 않은 트랜잭션을 감지하기 위한 패스가 활성 트랜잭션 로그에 작성됩니다. 메모리 내 OLTP 엔진은 로드할 검사점을 식별하고 시스템 테이블 로그 항목을 미리 로드합니다. 또한 일부 파일 할당 로그 레코드도 처리합니다.  
  
2.  다시 실행 단계. 이 단계는 디스크 기반 테이블과 메모리 최적화 테이블에서 동시에 실행됩니다.  
  
     디스크 기반 테이블의 경우 데이터베이스가 현재 시점으로 이동하고 커밋되지 않은 트랜잭션에 있는 잠금을 획득합니다.  
  
     메모리 최적화 테이블의 경우 데이터 및 델타 파일 쌍의 데이터가 메모리에 로드된 다음 마지막 지속성 검사점을 기반으로 활성 트랜잭션 로그를 사용하여 데이터를 업데이트합니다.  
  
     디스크 기반 테이블과 메모리 최적화 테이블에서 위의 연산이 완료되면 데이터베이스에 액세스할 수 있습니다.  
  
3.  실행 취소 단계. 이 단계에서는 커밋되지 않은 트랜잭션이 롤백됩니다.  
  
 메모리 최적화 테이블을 메모리에 로드하면 RTO(복구 시간 목표)의 성능에 영향을 줄 수 있습니다. 데이터 및 델타 파일에서 메모리 최적화 데이터를 로드하는 시간을 개선하기 위해 메모리 내 OLTP 엔진은 다음과 같이 데이터/델타 파일을 병렬로 로드합니다.  
  
-   델타 맵 필터 만들기. 델타 파일은 삭제된 행에 대한 참조를 저장합니다. 컨테이너당 하나의 스레드가 델타 파일을 읽고 델타 맵 필터를 만듭니다. 메모리 액세스에 최적화된 데이터 파일 그룹에는 하나 이상의 컨테이너가 있을 수 있습니다.  
  
-   데이터 파일 스트리밍.  델타 맵 필터가 생성되면 논리적 CPU와 같은 수의 스레드를 사용하여 데이터 파일을 읽습니다. 데이터 파일을 읽는 각 스레드는 데이터 행을 읽고 연결된 델타 맵을 확인한 다음 이 행이 삭제됨으로 표시되지 않은 경우에만 테이블에 행을 삽입합니다. 복구의 이 부분은 아래 설명과 같이 일부 경우에 CPU 바인딩될 수 있습니다.  
  
 ![메모리 액세스에 최적화된 테이블](../../database-engine/media/memory-optimized-tables.gif "Memory-optimized tables.")  
  
 메모리 액세스에 최적화된 테이블은 일반적으로 I/O 속도로 메모리에 로드할 수 있지만 데이터 행을 메모리에 로드하는 것이 더 느린 경우가 있습니다. 구체적인 경우는 다음과 같습니다.  
  
-   해시 인덱스의 버킷 수가 적으면 과도한 충돌이 발생하여 데이터 행 삽입이 느려질 수 있습니다. 이 경우 일반적으로 전체 CPU 사용률이 매우 높아지며 복구가 거의 끝날 때 특히 높아집니다. 해시 인덱스를 올바르게 구성한 경우 복구 시간에 영향을 미치지 않습니다.  
  
-   하나 이상의 비클러스터형 인덱스가 있는 대규모 메모리 최적화 테이블의 경우 생성 시간에 버킷 수가 조정되는 해시 인덱스와는 달리 비클러스터형 인덱스가 동적으로 증가하여 결과적으로 CPU 사용률이 높아집니다.  
  
## <a name="restoring-a-database-with-memory-optimized-tables"></a>메모리 액세스에 최적화된 테이블이 포함된 데이터베이스 복원  
 서버에 데이터베이스 복원에 충분한 메모리가 있음을 알고 있지만, 데이터베이스에서 필요한 메모리는 기존 리소스 풀의 일부분을 담당하게 되는 요구 사항이 있습니다.  데이터베이스가 있어야 리소스 풀에 바인딩을 만들 수 있음을 알고 있으므로  RESTORE WITH RECOVERY를 수행합니다.  이렇게 하면 복원을 위한 데이터베이스 디스크 이미지와 데이터베이스가 생성되지만 데이터베이스를 온라인으로 불러올 수 없으므로 메모리 내 OLTP 메모리가 사용됩니다.  
  
 이 시점에서 데이터베이스 바인딩에 대한 리소스 풀을 만들고 RESTORE WITH RECOVERY를 사용하여 복원된 데이터베이스를 온라인으로 불러옵니다.  데이터베이스를 온라인으로 불러오기 전에 바인딩이 존재하므로 메모리 내 OLTP 메모리 사용이 적절하게 설명됩니다. 이렇게 하려면 데이터베이스를 한 번만 복원해야 합니다. 첫번째 RESTORE 명령은 백업 헤더를 읽기만 하는 정보 제공 명령이며 마지막 명령은 실제 비트 복원 없이 단순히 복구를 트리거합니다.  
  
## <a name="see-also"></a>관련 항목  
 [메모리 액세스에 최적화된 테이블의 백업, 복원 및 복구](memory-optimized-tables.md)  
  
  
