---
title: 맞춤 | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- alignment issues [ODBC]
ms.assetid: 06a01e51-e7a5-495f-aa27-e304b0d005ff
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 205cc3ff95dd60db215150f46ae894fbb99bd9ff
ms.sourcegitcommit: e042272a38fb646df05152c676e5cbeae3f9cd13
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/27/2020
ms.locfileid: "81288608"
---
# <a name="alignment"></a>맞춤
ODBC 응용 프로그램의 정렬 문제는 일반적으로 다른 응용 프로그램에 있는 것과는 다릅니다. 즉, 대부분의 ODBC 응용 프로그램에는 맞춤에 문제가 있거나 없습니다. 주소를 정렬 하지 않는 경우 하드웨어 및 운영 체제에 따라 달라 지 며 약간의 성능이 저하 되거나 심각한 런타임 오류로 인해 발생할 수 있습니다. 따라서 ODBC 응용 프로그램 및 특히 이식 가능한 ODBC 응용 프로그램은 데이터를 제대로 정렬 하도록 주의 해야 합니다.  
  
 ODBC 응용 프로그램에서 맞춤 문제가 발생할 경우의 한 가지 예는 많은 메모리 블록을 할당 하 고 해당 메모리의 다른 부분을 결과 집합의 열에 바인딩하는 경우입니다. 이 오류는 제네릭 응용 프로그램이 런타임에 결과 집합의 모양을 결정 하 고 메모리를 적절 하 게 할당 및 바인딩하는 경우에 발생할 수 있습니다.  
  
 예를 들어 응용 프로그램이 사용자가 입력 한 **select** 문을 실행 하 고이 문에서 결과를 인출 한다고 가정 합니다. 프로그램이 작성 될 때이 결과 집합의 셰이프를 알 수 없기 때문에 응용 프로그램은 결과 집합을 만든 후에 각 열의 형식을 결정 하 고 메모리를 적절 하 게 바인딩합니다. 이 작업을 수행 하는 가장 쉬운 방법은 많은 메모리 블록을 할당 하 고 해당 블록의 여러 주소를 각 열에 바인딩하는 것입니다. 열의 데이터에 액세스 하기 위해 응용 프로그램은 해당 열에 바인딩된 메모리를 캐스팅 합니다.  
  
 다음 다이어그램에서는 예제 결과 집합 및 각 SQL 데이터 형식에 대 한 기본 C 데이터 형식을 사용 하 여 메모리 블록을 바인딩하는 방법을 보여 줍니다. 각 "X"는 메모리의 단일 바이트를 나타냅니다. 이 예에서는 열에 바인딩되는 데이터 버퍼만 보여 줍니다. 이 작업은 간단 하 게 수행 됩니다. 실제 코드에서는 길이/표시기 버퍼도 정렬 해야 합니다.  
  
 ![기본 C 데이터 형식으로 SQL 데이터 형식에 바인딩](../../../odbc/reference/develop-app/media/pr24.gif "pr24")  
  
 바인딩된 주소가 *주소* 배열에 저장 된다고 가정 하면 응용 프로그램은 다음 식을 사용 하 여 각 열에 바인딩된 메모리에 액세스 합니다.  
  
```  
(SQLCHAR *)       Address[0]  
(SQLSMALLINT *)   Address[1]  
(SQLINTEGER *)    Address[2]  
```  
  
 두 번째 및 세 번째 열에 바인딩된 주소는 홀수 번호 바이트에서 시작 하 고 세 번째 열에 바인딩된 주소는 SDWORD의 크기인 4로 나눌 수 없습니다. 일부 컴퓨터에서는이 문제가 발생 하지 않습니다. 다른 경우에는 약간의 성능 저하가 발생 합니다. 그래도 다른 경우에는 치명적인 런타임 오류가 발생 합니다. 더 나은 솔루션은 각 바인딩된 주소를 자연 맞춤 경계에 맞추는 것입니다. 이는 UCHAR, 소드의 경우 2, SDWORD의 경우 4 인 경우 다음 그림에 표시 된 결과를 제공 합니다. 여기서 "X"는 사용 되는 메모리의 바이트를 나타내고 "O"는 사용 되지 않는 메모리의 바이트를 나타냅니다.  
  
 ![자연 정렬 경계로 바인딩](../../../odbc/reference/develop-app/media/pr25.gif "pr25")  
  
 이 솔루션은 응용 프로그램의 모든 메모리를 사용 하지 않지만 맞춤 문제는 발생 하지 않습니다. 아쉽게도 각 열을 해당 형식에 따라 개별적으로 맞춰야 하므로이 솔루션을 구현 하는 데 상당한 양의 코드가 필요 합니다. 더 간단한 해결 방법은 다음 그림에 표시 된 예제에서 4의 가장 큰 맞춤 경계의 크기에 모든 열을 맞추는 것입니다.  
  
 ![최대 정렬 경계로 바인딩](../../../odbc/reference/develop-app/media/pr26.gif "pr26")  
  
 이 솔루션은 더 큰 구멍을 남겨 주지만 구현 하는 코드는 비교적 간단 하 고 빠릅니다. 대부분의 경우이는 사용 되지 않는 메모리에서 지불 된 페널티를 오프셋 합니다. 이 메서드를 사용 하는 예제는 [SQLBindCol 사용](../../../odbc/reference/develop-app/using-sqlbindcol.md)을 참조 하세요.
