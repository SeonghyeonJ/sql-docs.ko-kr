---
title: 정렬 | 마이크로 소프트 문서
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- alignment issues [ODBC]
ms.assetid: 06a01e51-e7a5-495f-aa27-e304b0d005ff
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 205cc3ff95dd60db215150f46ae894fbb99bd9ff
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81288608"
---
# <a name="alignment"></a>맞춤
ODBC 응용 프로그램의 정렬 문제는 일반적으로 다른 응용 프로그램과 다르지 않습니다. 즉, 대부분의 ODBC 응용 프로그램은 정렬에 거의 또는 전혀 문제가 없습니다. 주소를 정렬하지 않는 것에 대한 처벌은 하드웨어 및 운영 체제에 따라 다르며 약간의 성능 저하또는 치명적인 런타임 오류만큼 이나 주요 할 수 있습니다. 따라서 ODBC 응용 프로그램 및 특히 휴대용 ODBC 응용 프로그램은 데이터를 올바르게 정렬할 때 주의해야 합니다.  
  
 ODBC 응용 프로그램이 정렬 문제가 발생하는 경우의 한 가지 예는 큰 메모리 블록을 할당하고 결과 집합의 열에 해당 메모리의 다른 부분을 바인딩하는 경우입니다. 이는 제네릭 응용 프로그램이 런타임에 설정된 결과 의 모양을 결정하고 그에 따라 메모리를 할당하고 바인딩해야 할 때 발생할 가능성이 높습니다.  
  
 예를 들어 응용 프로그램이 사용자가 입력한 **SELECT** 문을 실행하고 이 명령문에서 결과를 가져온다고 가정합니다. 이 결과 집합의 셰이프는 프로그램을 작성할 때 알 수 없으므로 응용 프로그램은 결과 집합을 만든 후 각 열의 형식을 결정하고 그에 따라 메모리를 바인딩해야 합니다. 이 작업을 수행하는 가장 쉬운 방법은 큰 메모리 블록을 할당하고 해당 블록의 다른 주소를 각 열에 바인딩하는 것입니다. 열의 데이터에 액세스하기 위해 응용 프로그램은 해당 열에 바인딩된 메모리를 캐스팅합니다.  
  
 다음 다이어그램에서는 샘플 결과 집합과 각 SQL 데이터 형식에 대한 기본 C 데이터 형식을 사용하여 메모리 블록이 바인딩되는 방법을 보여 주며, 이 에 바인딩되는 방법을 보여 주실 수 있습니다. 각 "X"는 단일 메모리 바이트를 나타냅니다. 이 예제에서는 열에 바인딩된 데이터 버퍼만 보여 있습니다. 이것은 단순하게 수행됩니다. 실제 코드에서는 길이/표시기 버퍼도 정렬되어야 합니다.  
  
 ![기본 C 데이터 형식으로 SQL 데이터 형식에 바인딩](../../../odbc/reference/develop-app/media/pr24.gif "pr24")  
  
 바인딩된 주소가 *Address* 배열에 저장된다고 가정하면 응용 프로그램은 다음 식을 사용하여 각 열에 바인딩된 메모리에 액세스합니다.  
  
```  
(SQLCHAR *)       Address[0]  
(SQLSMALLINT *)   Address[1]  
(SQLINTEGER *)    Address[2]  
```  
  
 두 번째 및 세 번째 열에 바인딩된 주소는 홀수 번호 바이트에서 시작하고 세 번째 열에 바인딩된 주소는 SDWORD 크기의 4로 나눌 수 없습니다. 일부 컴퓨터에서는 문제가 되지 않습니다. 다른 사람에, 그것은 약간의 성능 저하를 일으킬 것 이다; 다른 사람에, 그것은 치명적인 런타임 오류를 일으킬 것입니다. 더 나은 해결책은 자연 정렬 경계에 각 바운드 주소를 정렬하는 것입니다. UCHAR의 경우 1, SWord의 경우 2, SDWORD의 경우 4라고 가정하면 다음 그림에 표시된 결과를 나타내며, 여기서 "X"는 사용되는 메모리 바이트를 나타내고 "O"는 사용되지 않는 메모리 바이트를 나타냅니다.  
  
 ![자연 정렬 경계로 바인딩](../../../odbc/reference/develop-app/media/pr25.gif "pr25")  
  
 이 솔루션은 응용 프로그램의 메모리를 모두 사용하지는 않지만 정렬 문제가 발생하지는 않습니다. 안타깝게도 각 열은 형식에 따라 개별적으로 정렬되어야 하므로 이 솔루션을 구현하는 데는 상당한 양의 코드가 필요합니다. 더 간단한 해결책은 다음 그림에 표시된 예제에서 4인 가장 큰 정렬 경계의 크기에 모든 열을 정렬하는 것입니다.  
  
 ![최대 정렬 경계로 바인딩](../../../odbc/reference/develop-app/media/pr26.gif "pr26")  
  
 이 솔루션은 더 큰 구멍을 남기지만 구현하는 코드는 비교적 간단하고 빠릅니다. 대부분의 경우 사용되지 않는 메모리에서 지불한 페널티를 상쇄합니다. 이 메서드를 사용하는 예제에서는 [SQLBindCol 을 사용합니다.](../../../odbc/reference/develop-app/using-sqlbindcol.md)
