---
title: 맞춤 | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- alignment issues [ODBC]
ms.assetid: 06a01e51-e7a5-495f-aa27-e304b0d005ff
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: e4c86fd8fba66e6424b41fa4b80b42fc089e6d64
ms.sourcegitcommit: f7fced330b64d6616aeb8766747295807c92dd41
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/23/2019
ms.locfileid: "63287456"
---
# <a name="alignment"></a>맞춤
ODBC 응용 프로그램에서 맞춤 문제는 다른 응용 프로그램에서 보다 일반적으로 더 다릅니다. 즉, 대부분의 ODBC 응용 프로그램 문제가 없거나 거의 맞춤을 사용 합니다. 정렬 되어 있지 않기 주소에 대 한 페널티의 하드웨어 및 운영 체제를 사용 하 여 다르며 성능이 약간 저하 같은 사소한 문제로 또는 런타임 오류로으로 주요 일 수 있습니다. 따라서 ODBC 응용 프로그램 및 이식 가능한 ODBC 응용 프로그램에 특히 주의 해야 데이터를 제대로 정렬 합니다.  
  
 하나의 ODBC 응용 프로그램에서 맞춤 문제를 발생 하는 경우의 예는 큰 메모리 블록을 할당할 때 결과 집합의 열에 해당 메모리의 다른 부분에 바인딩합니다. 이 일반 응용 프로그램 런타임 시 결과 집합의 셰이프를 결정 하 고 할당 하 고 해야 메모리를 적절 하 게 바인딩할 때 발생할 가능성이 가장 높습니다.  
  
 예를 들어, 응용 프로그램 실행을 **선택** 문을 사용자가 입력 하 고이 문의 결과 인출 합니다. 이 결과 집합의 셰이프를 알 수 없는 경우 프로그램이 작성 된 응용 프로그램 결과 집합을 만든 후 각 열의 형식을 결정 하며 메모리를 적절 하 게 바인딩합니다. 이 작업을 수행 하는 가장 쉬운 방법은 큰 메모리 블록을 할당 하 고 각 열에 해당 블록에서 다른 주소를 바인딩할 방법은입니다. 열의 데이터에 액세스 하려면 응용 프로그램에는 해당 열에 바인딩된 메모리를 캐스팅 합니다.  
  
 다음 다이어그램에서는 설정 하 고 각 SQL 데이터 형식에 대 한 기본 C 데이터 형식을 사용 하 여 메모리 블록을 바인딩할 수 있습니다 하는 방법 샘플 결과 보여 줍니다. 각 "X"는 단일 바이트를의 메모리를 나타냅니다. (이 예제에서는 열에 바인딩된 데이터 버퍼를 표시 하는 데 사용 합니다. 간단히 하기 위해 수행 됩니다. 실제 코드에 길이/표시기 버퍼도 정렬 되어야 합니다.)  
  
 ![SQL 데이터 형식에 기본 C 데이터 형식에 바인딩](../../../odbc/reference/develop-app/media/pr24.gif "pr24")  
  
 에 저장 된 바인딩된 주소를 가정 합니다 *주소* 배열 응용 프로그램이 다음 식은 각 열에 바인딩된 메모리 액세스에 사용:  
  
```  
(SQLCHAR *)       Address[0]  
(SQLSMALLINT *)   Address[1]  
(SQLINTEGER *)    Address[2]  
```  
  
 시작한 하는 주소 바인딩된 두 번째 및 세 번째 열에서 홀수 바이트는 SDWORD의 크기는 4로 나눌 수 없으면 주소 세 번째 열에 바인딩되어 있음을 알 수 있습니다. 일부 컴퓨터에서이 문제가 되지 않습니다. 다른, 성능이 약간 저하; 하면 여전히 다른 런타임 오류가 발생 합니다. 더 나은 솔루션은 해당 자연 맞춤 경계에 바인딩된 각 주소에 맞게 것입니다. 검 2 및 4는 SDWORD 아닌 UCHAR에 대 한 1 이라고 가정 하 고이 통해 여기서 "X"가 사용 되는 메모리의 바이트 이며 "O" 사용 되지 않는 메모리의 바이트를 나타내며 다음 그림에 표시 된 결과입니다.  
  
 ![자연 정렬 경계로 바인딩](../../../odbc/reference/develop-app/media/pr25.gif "pr25")  
  
 이 솔루션으로 사용 하지 않는 응용 프로그램의 메모리 중 전부는 동안 맞춤 문제는 발생 하지 않습니다. 에이 솔루션을 구현 하는 코드의 상당한으로 각 열 형식에 따라 개별적으로 정렬 해야 합니다. 가장 큰 맞춤 경계는 4의 크기에 모든 열에 맞게 더욱 간단한 솔루션은 다음 그림에 표시 된 예에서입니다.  
  
 ![최대 정렬 경계로 바인딩](../../../odbc/reference/develop-app/media/pr26.gif "pr26")  
  
 더 큰 구멍 유지 하는이 솔루션을 구현 하는 코드 이지만 비교적 간단 하 고 빠른 합니다. 대부분의 경우이 사용 되지 않는 메모리에서 유료 페널티에 만큼 오프셋 합니다. 이 메서드를 사용 하는 예제를 보려면 [를 사용 하 여 SQLBindCol](../../../odbc/reference/develop-app/using-sqlbindcol.md)합니다.
