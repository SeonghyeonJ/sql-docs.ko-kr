---
title: 사용할 데이터베이스 기능 고려 | 마이크로 소프트 문서
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- interoperability [ODBC], database features
ms.assetid: 59760114-508e-46c5-81d2-8f2498c0d778
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: a9d966781def1c3eab6a9568eab07ab591326171
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81299013"
---
# <a name="considering-database-features-to-use"></a>사용할 데이터베이스 기능 고려
기본 상호 운용성 수준을 알 수 있는 후에는 응용 프로그램에서 사용하는 데이터베이스 기능을 고려해야 합니다. 예를 들어 응용 프로그램이 실행되는 SQL 문은 무엇입니까? 응용 프로그램에서 스크롤 가능한 커서를 사용합니까? 트랜잭션을? 절차? 긴 데이터? 모든 DBMS에서 지원되지 않는 기능에 대한 아이디어는 [SQLGetInfo,](../../../odbc/reference/syntax/sqlgetinfo-function.md) [SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)및 [SQLSetStmtAttr](../../../odbc/reference/syntax/sqlsetstmtattr-function.md) 함수 설명 및 [부록 C: SQL 문법을](../../../odbc/reference/appendixes/appendix-c-sql-grammar.md)참조하십시오. 응용 프로그램에 필요한 기능은 대상 DBMS 목록에서 일부 DBMS를 제거할 수 있습니다. 또한 응용 프로그램이 많은 DBMS를 쉽게 대상으로 지정할 수 있음을 보여줄 수도 있습니다.  
  
 예를 들어 필요한 기능이 단순하면 일반적으로 높은 수준의 상호 운용성으로 구현할 수 있습니다. 간단한 **SELECT** 문을 실행하고 정방향 전용 커서로 결과를 검색하는 응용 프로그램은 단순함으로 상호 운용이 가능할 수 있습니다.  
  
 그러나 스크롤 가능한 커서, 위치 업데이트 및 삭제 문 및 프로시저와 같이 필요한 기능이 더 복잡한 경우 종종 장단점이 있어야 합니다. 다음과 같은 몇 가지 가능성이 있습니다.  
  
-   **낮은 상호 운용성, 더 많은 기능.** 응용 프로그램에는 기능이 포함되어 있지만 이를 지원하는 DBMS에서만 작동합니다.  
  
-   **상호 운용성이 높고 기능이 줄어듭니다.** 응용 프로그램은 기능을 삭제하지만 더 많은 DBMS와 함께 작동합니다.  
  
-   **높은 상호 운용성, 선택적 기능.** 응용 프로그램에는 기능이 포함되어 있지만 이를 지원하는 DBMS에서만 사용할 수 있습니다.  
  
-   **높은 상호 운용성, 더 많은 기능.** 응용 프로그램은 이를 지원하는 DBMS와 함께 기능을 사용하고 그렇지 않은 DBMS에 대해 에뮬레이트합니다.  
  
 처음 두 경우는 지원되는 모든 DBMS에서 사용되거나 지원되지 않는 기능이 사용되므로 구현하기가 비교적 간단합니다. 후자의 두 경우는 다른 한편으로는 더 복잡합니다. 두 경우 모두 DBMS가 기능을 지원하는지 여부를 확인하고 마지막 경우에 이러한 기능을 에뮬레이트하기 위해 잠재적으로 많은 양의 코드를 작성해야 합니다. 따라서 이러한 체계는 더 많은 개발 시간이 필요하며 런타임에 느려질 수 있습니다.  
  
 단일 데이터 원본에 연결할 수 있는 일반 쿼리 응용 프로그램을 고려합니다. 응용 프로그램은 사용자의 쿼리를 수락하고 결과를 창에 표시합니다. 이제이 응용 프로그램에 사용자가 동시에 여러 쿼리의 결과를 표시 할 수있는 하나의 기능이 있다고 가정합니다. 즉, 쿼리를 실행하고 일부 결과를 보고 다른 쿼리를 실행하고 일부 결과를 보고 첫 번째 쿼리로 돌아갈 수 있습니다. 일부 드라이버는 단일 활성 문만 지원하기 때문에 상호 운용성 문제가 발생합니다.  
  
 응용 프로그램에는 **SQLGetInfo에서**SQL_MAX_CONCURRENT_ACTIVITIES 옵션에 대해 드라이버가 반환하는 내용에 따라 여러 가지 선택 사항이 있습니다.  
  
-   **항상 여러 쿼리를 지원합니다.** 드라이버에 연결한 후 응용 프로그램은 활성 문의 수를 확인합니다. 드라이버가 하나의 활성 문만 지원하는 경우 응용 프로그램은 연결을 닫고 드라이버가 필요한 기능을 지원하지 않는다는 것을 사용자에게 알립니다. 응용 프로그램은 구현하기 쉽고 모든 기능을 가지고 있지만 상호 운용성이 낮습니다.  
  
-   **여러 쿼리를 지원하지 마십시오.** 응용 프로그램은 기능을 모두 삭제합니다. 구현하기 쉽고 상호 운용성이 높지만 기능이 적습니다.  
  
-   **드라이버가 수행하는 경우에만 여러 쿼리를 지원합니다.** 드라이버에 연결한 후 응용 프로그램은 활성 문의 수를 확인합니다. 이 응용 프로그램을 사용하면 드라이버가 여러 활성 문을 지원하는 경우에만 이미 활성 상태일 때 새 문을 시작할 수 있습니다. 응용 프로그램은 더 높은 기능과 상호 운용성을 가지고 있지만 구현하기가 어렵습니다.  
  
-   **항상 여러 쿼리를 지원하고 필요한 경우 에뮬레이트합니다.** 드라이버에 연결한 후 응용 프로그램은 활성 문의 수를 확인합니다. 응용 프로그램은 항상 사용자가 이미 활성 상태일 때 새 문을 시작할 수 있도록 합니다. 드라이버가 하나의 활성 문만 지원하는 경우 응용 프로그램은 해당 드라이버에 대한 추가 연결을 열고 해당 연결에서 새 문을 실행합니다. 응용 프로그램은 모든 기능과 높은 상호 운용성을 가지고 있지만 구현하기가 어렵습니다.
