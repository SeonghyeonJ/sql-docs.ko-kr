---
title: 프로시저를 사용 하는 경우 Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQL statements [ODBC], procedures
- procedures [ODBC], about procedures
ms.assetid: 7dc9e327-dd54-4b10-9f66-9ef5c074f122
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 6f25b629372bbe089489cccdbfa0258dafef3dd0
ms.sourcegitcommit: b87d36c46b39af8b929ad94ec707dee8800950f5
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 02/08/2020
ms.locfileid: "68078958"
---
# <a name="when-to-use-procedures"></a>프로시저 사용 시기
프로시저를 사용 하면 SQL 문이 응용 프로그램에서 데이터 원본으로 이동 한다는 사실을 기반으로 하는 여러 가지 이점이 있습니다. 응용 프로그램의 남은 사항은 상호 운용 가능한 프로시저 호출입니다. 이러한 이점은 다음과 같습니다.  
  
-   **성능** 프로시저는 일반적으로 SQL 문을 실행 하는 가장 빠른 방법입니다. 준비 된 실행과 마찬가지로 문은 두 개의 별도 단계로 컴파일되고 실행 됩니다. 준비 된 실행과 달리 프로시저는 런타임에만 실행 됩니다. 서로 다른 시간에 컴파일됩니다.  
  
-   **비즈니스 규칙** *비즈니스 규칙* 은 회사에서 업무를 수행 하는 방식에 대 한 규칙입니다. 예를 들어 Sales Person 제목의 사람만이 새 판매 주문을 추가할 수 있습니다. 이러한 규칙을 프로시저에 배치 하면 개별 회사에서 응용 프로그램 코드를 수정할 필요 없이 응용 프로그램에서 호출 하는 프로시저를 다시 작성 하 여 세로 응용 프로그램을 사용자 지정할 수 있습니다. 예를 들어 주문 입력 응용 프로그램은 고정 된 수의 매개 변수를 사용 하 여 **Insertorder** 프로시저를 호출할 수 있습니다. **Insertorder** 는 회사 마다 다를 수 있습니다.  
  
-   **Replaceability** 프로시저에 비즈니스 규칙을 배치 하는 것과 밀접 하 게 관련 된 것은 응용 프로그램을 다시 컴파일하지 않고도 프로시저를 대체할 수 있다는 사실입니다. 회사에서 응용 프로그램을 구입 하 고 설치한 후에 비즈니스 규칙이 변경 되는 경우 해당 규칙을 포함 하는 프로시저를 변경할 수 있습니다. 응용 프로그램의 관점에서 아무것도 변경 되지 않았습니다. 특정 작업을 수행 하기 위해 여전히 특정 프로시저를 호출 합니다.  
  
-   **DBMS 관련 SQL** 프로시저는 응용 프로그램에서 DBMS 관련 SQL을 활용 하는 방법을 제공 하며 계속 상호 운용할 수 있습니다. 예를 들어 SQL에서 흐름 제어 문을 지 원하는 DBMS에 대 한 프로시저는 오류를 포착 하 고 복구할 수 있습니다. 반면 흐름 제어 문을 지원 하지 않는 DBMS에 대 한 프로시저는 단순히 오류를 반환할 수 있습니다.  
  
-   **트랜잭션이 남아 있는 프로시저** 일부 데이터 원본에서 연결에 대 한 모든 준비 된 문에 대 한 액세스 계획은 트랜잭션이 커밋되거나 롤백될 때 삭제 됩니다. 데이터 원본에 영구적으로 저장 되는 프로시저에 SQL 문을 배치 하 여 문이 트랜잭션에 남아 있습니다. 준비 됨, 부분적으로 준비 됨 또는 준비 되지 않음 상태로 유지 되는 프로시저는 DBMS 마다 다릅니다.  
  
-   **별도 개발** 응용 프로그램의 나머지 부분과 별도로 프로시저를 개발할 수 있습니다. 대기업에서는이를 통해 매우 전문화 된 프로그래머의 기술을 더욱 활용 하는 방법을 제공할 수 있습니다. 즉, 응용 프로그램 프로그래머는 사용자 인터페이스 코드를 작성할 수 있으며, 데이터베이스 프로그래머는 프로시저를 작성할 수 있습니다.  
  
 프로시저는 일반적으로 수직 및 사용자 지정 응용 프로그램에서 사용 됩니다. 이러한 응용 프로그램은 고정 된 작업을 수행 하는 경향이 있으며, 이러한 응용 프로그램에서 프로시저 호출을 하드 코딩할 수 있습니다. 예를 들어 주문 입력 응용 프로그램은 **insertorder**, **deleteorder**, **updateorder**및 **getorders**프로시저를 호출할 수 있습니다.  
  
 제네릭 응용 프로그램에서 프로시저를 호출 하는 이유는 거의 없습니다. 프로시저는 일반적으로 특정 응용 프로그램의 컨텍스트에서 작업을 수행 하기 위해 작성 되므로 제네릭 응용 프로그램을 사용 하지 않습니다. 예를 들어 스프레드시트는 앞에서 언급 한 **Insertorder** 프로시저를 호출할 이유가 없습니다. 또한 제네릭 응용 프로그램은 런타임 시 더 빠른 문 실행을 제공 하는 프로시저를 생성 해서는 안 됩니다. 이는 준비 또는 직접 실행 보다 속도가 느릴 수도 있고 DBMS 별 SQL 문도 필요 합니다.  
  
 이에 대 한 예외는 응용 프로그램 개발 환경으로, 프로그래머 들이 프로시저를 실행 하는 SQL 문을 작성 하는 방법을 제공 하 고 프로그래머가 프로시저를 테스트 하는 방법을 제공 하는 경우가 많습니다. 이러한 환경에서는 **sqlprocedures** 를 호출 하 여 입력, 입/출력 및 출력 매개 변수, 프로시저 반환 값 및 프로시저에 의해 생성 된 결과 집합의 열을 나열 하는 데 사용할 수 있는 프로시저 및 **SQLProcedureColumns** 를 나열 합니다. 그러나 이러한 프로시저는 각 데이터 원본에서 미리 개발 해야 합니다. 이렇게 하려면 DBMS 별 SQL 문이 필요 합니다.  
  
 프로시저를 사용 하는 경우 세 가지 주요 단점이 있습니다. 첫 번째는 응용 프로그램을 실행할 각 DBMS에 대해 프로시저를 작성 하 고 컴파일해야 한다는 것입니다. 이는 사용자 지정 응용 프로그램에서 문제가 되지 않지만 많은 Dbms에서 실행 되도록 설계 된 수직 응용 프로그램의 개발 및 유지 관리 시간을 크게 향상 시킬 수 있습니다.  
  
 두 번째 단점은 많은 Dbms에서 프로시저를 지원 하지 않는다는 것입니다. 이는 많은 Dbms에서 실행 되도록 설계 된 수직 응용 프로그램에 문제가 있을 가능성이 높습니다. 프로시저가 지원 되는지 여부를 확인 하기 위해 응용 프로그램은 SQL_PROCEDURES 옵션으로 **SQLGetInfo** 를 호출 합니다.  
  
 응용 프로그램 개발 환경에 특히 적용 되는 세 번째 단점은 ODBC는 프로시저를 만들기 위한 표준 문법을 정의 하지 않는다는 것입니다. 즉, 응용 프로그램은 interoperably 프로시저를 호출할 수 있지만 interoperably을 만들 수는 없습니다.
