---
title: 사용 시기 | 마이크로 소프트 문서
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQL statements [ODBC], procedures
- procedures [ODBC], about procedures
ms.assetid: 7dc9e327-dd54-4b10-9f66-9ef5c074f122
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 31aeea226bc8c8aa41f748d1d9a97d55147c4d67
ms.sourcegitcommit: ce94c2ad7a50945481172782c270b5b0206e61de
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/14/2020
ms.locfileid: "81289100"
---
# <a name="when-to-use-procedures"></a>프로시저 사용 시기
프로시저를 사용하면 응용 프로그램에서 데이터 원본으로 SQL 문을 이동한다는 사실에 따라 프로시저를 사용할 때 여러 가지 이점이 있습니다. 응용 프로그램에 남아 있는 것은 상호 운용 가능한 프로시저 호출입니다. 이러한 장점은 다음과 같습니다.  
  
-   **성능** 프로시저는 일반적으로 SQL 문을 실행하는 가장 빠른 방법입니다. 준비된 실행과 마찬가지로 문은 두 개의 별도 단계로 컴파일되고 실행됩니다. 준비된 실행과 달리 프로시저는 런타임에만 실행됩니다. 다른 시간에 컴파일됩니다.  
  
-   **비즈니스 규칙** *비즈니스 규칙은* 회사가 비즈니스를 수행하는 방식에 대한 규칙입니다. 예를 들어 영업 담당자라는 제목의 사람만 새 판매 주문을 추가할 수 있습니다. 절차에 이러한 규칙을 배치하면 개별 회사에서 응용 프로그램 코드를 수정하지 않고도 응용 프로그램에서 호출한 프로시저를 다시 작성하여 수직 응용 프로그램을 사용자 지정할 수 있습니다. 예를 들어 주문 입력 응용 프로그램은 고정된 수의 매개 변수를 가진 프로시저 **InsertOrder를** 호출할 수 있습니다. **InsertOrder가** 구현되는 정확한 방법은 회사마다 다를 수 있습니다.  
  
-   **교체 가능성** 절차에 비즈니스 규칙을 배치하는 것과 밀접한 관련이 있는 것은 응용 프로그램을 다시 컴파일하지 않고도 프로시저를 대체할 수 있다는 사실입니다. 회사에서 응용 프로그램을 구입하고 설치한 후 비즈니스 규칙이 변경되면 해당 규칙이 포함된 절차를 변경할 수 있습니다. 응용 프로그램의 관점에서, 아무것도 변경되지 않았습니다; 여전히 특정 작업을 수행 하기 위해 특정 프로시저를 호출 합니다.  
  
-   **DBMS별 SQL** 프로시저는 응용 프로그램이 DBMS 관련 SQL을 악용하고 상호 운용가능한 상태를 유지할 수 있는 방법을 제공합니다. 예를 들어 SQL에서 흐름 제어 문을 지원하는 DBMS프로시저는 오류를 트랩하고 복구할 수 있으며, 흐름 제어 문을 지원하지 않는 DBMS의 프로시저는 단순히 오류를 반환할 수 있습니다.  
  
-   **프로시저가 거래에서 살아남는다** 일부 데이터 원본에서는 트랜잭션이 커밋되거나 롤백될 때 연결에 대해 준비된 모든 명령문에 대한 액세스 계획이 삭제됩니다. 데이터 원본에 영구적으로 저장되는 프로시저에 SQL 문을 배치하면 명령문은 트랜잭션에서 유지됩니다. 절차가 준비되거나 부분적으로 준비된 상태에서 생존하는지 또는 준비되지 않은 상태는 DBMS에 따라 다릅니다.  
  
-   **별도의 개발** 절차는 응용 프로그램의 나머지 부분과 별도로 개발할 수 있습니다. 대기업에서는 고도로 전문화된 프로그래머의 기술을 더욱 활용할 수 있는 방법을 제공할 수 있습니다. 즉, 응용 프로그램 프로그래머는 사용자 인터페이스 코드를 작성할 수 있으며 데이터베이스 프로그래머는 프로시저를 작성할 수 있습니다.  
  
 절차는 일반적으로 수직 및 사용자 지정 응용 프로그램에서 사용됩니다. 이러한 응용 프로그램은 고정된 작업을 수행하는 경향이 있으며 프로시저 호출을 하드 코딩할 수 있습니다. 예를 들어 주문 입력 응용 프로그램은 프로시저를 호출할 수 있습니다 **삽입 순서,** 삭제 **주문,** **업데이트 주문**및 **GetOrders**.  
  
 일반 응용 프로그램에서 프로시저를 호출할 이유가 거의 없습니다. 프로시저는 일반적으로 특정 응용 프로그램의 컨텍스트에서 작업을 수행하기 위해 작성되므로 일반 응용 프로그램에는 아무런 사용이 필요하지 않습니다. 예를 들어 스프레드시트는 방금 언급한 **InsertOrder** 프로시저를 호출할 이유가 없습니다. 또한 일반 응용 프로그램은 더 빠른 명령문 실행을 제공하기 위해 런타임에 프로시저를 생성해서는 안 됩니다. 준비되거나 직접 실행보다 속도가 느릴 뿐만 아니라 DBMS 별 SQL 문도 필요합니다.  
  
 이에 대한 예외는 프로그래머가 프로시저를 실행하고 프로그래머가 프로시저를 테스트할 수 있는 SQL 문을 작성하는 방법을 제공하는 응용 프로그램 개발 환경입니다. 이러한 환경은 **SQLProcedures를** 호출하여 사용 가능한 프로시저및 **SQLProcedureColumn을** 호출하여 입력, 입력/출력 및 출력 매개 변수, 프로시저 반환 값 및 프로시저에 의해 생성된 모든 결과 집합의 열을 나열합니다. 그러나 이러한 절차는 각 데이터 원본에 대해 사전에 개발되어야 합니다. 이렇게 하려면 DBMS별 SQL 문이 필요합니다.  
  
 절차를 사용하는 데는 세 가지 주요 단점이 있습니다. 첫 번째는 응용 프로그램을 실행하는 각 DBMS에 대해 프로시저를 작성하고 컴파일해야 한다는 것입니다. 사용자 지정 응용 프로그램에는 문제가 되지 않지만 여러 DBMS로 실행되도록 설계된 수직 응용 프로그램의 개발 및 유지 관리 시간이 크게 늘어칠 수 있습니다.  
  
 두 번째 단점은 많은 DBMS가 절차를 지원하지 않는다는 것입니다. 다시 말하지만, 이는 여러 DBMS로 실행되도록 설계된 수직 응용 프로그램에 문제가 될 가능성이 높습니다. 프로시저가 지원되는지 여부를 확인하기 위해 응용 프로그램은 SQL_PROCEDURES 옵션을 사용하여 **SQLGetInfo를** 호출합니다.  
  
 응용 프로그램 개발 환경에 특히 적용되는 세 번째 단점은 ODBC가 프로시저를 만들기 위한 표준 문법을 정의하지 않는다는 것입니다. 즉, 응용 프로그램은 프로시저를 상호 운용적으로 호출할 수 있지만 상호 운용적으로 만들 수는 없습니다.
