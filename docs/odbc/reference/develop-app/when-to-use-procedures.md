---
title: 프로시저를 사용 하는 경우 | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- SQL statements [ODBC], procedures
- procedures [ODBC], about procedures
ms.assetid: 7dc9e327-dd54-4b10-9f66-9ef5c074f122
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 6f25b629372bbe089489cccdbfa0258dafef3dd0
ms.sourcegitcommit: b2464064c0566590e486a3aafae6d67ce2645cef
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 07/15/2019
ms.locfileid: "68078958"
---
# <a name="when-to-use-procedures"></a>프로시저 사용 시기
모든 프로시저를 사용 하 여 있다는 사실에 따라 이동 SQL 문을 응용 프로그램 데이터 원본으로,의 절차를 사용 하는 이점이 있습니다. 응용 프로그램에 그대로 새로운 상호 운용 가능한 프로시저 호출입니다. 이러한 장점은 다음과 같습니다.  
  
-   **성능** 프로시저는 일반적으로 SQL 문을 실행 하는 가장 빠른 방법입니다. 와 같은 실행 준비 문을 컴파일 및 두 개의 별도 단계에서 실행 합니다. 준비 된 실행에서 달리 프로시저는 실행된 시간에만 실행 됩니다. 다른 시간에 컴파일됩니다.  
  
-   **비즈니스 규칙** A *비즈니스 규칙* 회사 비즈니스를 수행 하는 방법에 대 한 규칙이 있습니다. 예를 들어 새 판매 주문을 추가 하려면 영업 사원 제목을 가진 사용자만 허용 될 수 있습니다. 프로시저에서 이러한 규칙을 배치 하면 개별 회사 응용 프로그램 코드를 수정 하지 않고도 응용 프로그램에서 호출 하는 절차를 다시 작성 하 여 수직 응용 프로그램을 사용자 지정할 수 있습니다. 예를 들어 주문 입력 응용 프로그램 프로시저를 호출할 수 있습니다 **InsertOrder** 고정된 된 수의 매개 변수를 사용 하 여 정확 하 게 **InsertOrder** 구현 되는 회사 마다 다를 수 있습니다.  
  
-   **Replaceability** 사실은 응용 프로그램을 다시 컴파일하지 않고 프로시저를 대체할 수 있습니다 밀접 하 게 프로시저에 비즈니스 규칙을 배치 합니다. 회사에 구입 하 고 응용 프로그램을 설치한 후 비즈니스 규칙을 변경 하는 경우 회사는 해당 규칙을 포함 하는 프로시저를 변경할 수 있습니다. 응용 프로그램의 관점에서 아무 것도 변경 되었습니다. 여전히 특정 태스크를 수행 하는 특정 프로시저를 호출 합니다.  
  
-   **DBMS 관련 SQL** 프로시저 DBMS 관련 SQL을 악용 하 고 계속 상호 운용 가능한 응용 프로그램에 대 한 방법을 제공 합니다. 예를 들어 SQL의 흐름 제어 문을 지 원하는 DBMS에서 프로시저를 트래핑 하 고 제어 흐름 문을 지원 하지 않는 DBMS에서 프로시저 오류가 반환 될 수 있습니다 하는 동안 오류에서 복구 수 있습니다.  
  
-   **프로시저에서 트랜잭션을 살아** 일부 데이터 원본의 경우에 트랜잭션이 커밋되거나 롤백될 때 연결에서 모든 준비 된 문에 대 한 액세스 계획 삭제 됩니다. 데이터 원본에 영구적으로 저장 되는 프로시저에서 SQL 문을 배치 하 여 문의 트랜잭션을 유지 합니다. 준비 된, 부분적으로 준비 절차 생존 하는 여부를 또는 준비 되지 않은 상태가 DBMS 전용입니다.  
  
-   **개발 구분** 프로시저 응용 프로그램의 나머지 부분과에서 별도로 개발할 수 있습니다. 많은 기업에서이 추가로 고도의 전문된 프로그래머의 기술을 활용 하는 방법은 제공할 수 있습니다. 즉, 응용 프로그램 프로그래머는 사용자 인터페이스 코드를 작성할 수 및 데이터베이스 프로그래머는 프로시저를 작성할 수 있습니다.  
  
 프로시저는 일반적으로 수직 및 사용자 지정 응용 프로그램에서 사용 됩니다. 이러한 응용 프로그램이은 고정 된 작업을 수행 하는 경향이 있습니다 이며에 하드 코딩 프로시저 호출 수입니다. 주문 입력 응용 프로그램 수는 프로시저를 호출 하는 예를 들어 **InsertOrder**, **DeleteOrder**하십시오 **UpdateOrder**, 및 **GetOrders** .  
  
 일반 응용 프로그램에서 프로시저를 호출 하는 작은 필요가 있습니다. 일반적으로 사용 하는 프로시저 특정 응용 프로그램의 컨텍스트에서 작업을 수행 기록 되 고 있으므로 사용 되지 않은 제네릭 응용 프로그램입니다. 예를 들어 스프레드시트에 호출 하지 않아도 합니다 **InsertOrder** 방금 전에 말씀 하는 프로시저입니다. 또한 일반 응용 프로그램 구성 하지 않아야 프로시저 런타임에 빠르게 문 실행을 제공 하기 위한 서비스 뿐만 아니라 가능성이 준비 된 또는 직접 실행 보다 속도가 떨어지므로 DBMS 관련 SQL 문의 해야 합니다.  
  
 이 예외는 종종 프로그래머가 프로시저를 실행 및 프로시저를 테스트 하려면 프로그래머는 방법을 제공할 수 있는 SQL 문을 만들 수 있는 방법을 제공 하는 응용 프로그램 개발 환경입니다. 이러한 환경 호출 **SQLProcedures** 목록 사용할 수 있는 프로시저와 **SQLProcedureColumns** 입력, 입/출력 및 출력 매개 변수를 나열 하려면 프로시저 반환 값 및 열 프로시저에서 만들어진 모든 결과 집합입니다. 그러나 이러한 프로시저 개발 해야 미리 각 데이터 원본에서 이렇게 하려면 DBMS 관련 SQL 문의 해야 합니다.  
  
 프로시저를 사용 하 여 세 가지 주요 단점이 있습니다. 즉 프로시저 작성 및 응용 프로그램 실행 되어 있는 각 DBMS에 대해 컴파일된 되도록 해야 합니다. 이 사용자 지정 응용 프로그램에 대 한 문제를 개발 및 다양 한 Dbms 사용 하 여 실행 하도록 설계 하는 세로 응용 프로그램에 대 한 유지 관리 시간 크게 높일 수 있으므로 합니다.  
  
 두 번째 단점은 여러 Dbms는 프로시저를 지원 하지 않습니다. 마찬가지로이 다양 한 Dbms 사용 하 여 실행 하도록 설계 하는 세로 응용 프로그램에 대 한 문제가 있을 가능성이 가장 높은 합니다. 프로시저를 지원 하는지 여부를 확인 하려면 응용 프로그램 호출 **SQLGetInfo** SQL_PROCEDURES 옵션을 사용 합니다.  
  
 세 번째, 응용 프로그램 개발 환경에 특히 적용할 수 있으며 단점은 ODBC 프로시저를 만드는 표준 문법을 정의 하지 않습니다. 즉, 응용 프로그램 interoperably 프로시저를 호출할 수 있습니다, 있지만 이러한 만들 수는 없습니다 interoperably 합니다.
