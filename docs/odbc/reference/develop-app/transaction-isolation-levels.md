---
title: 트랜잭션 격리 수준 | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
helpviewer_keywords:
- dirty reads [ODBC]
- isolation levels [ODBC]
- nonrepeatable reads [ODBC]
- read uncommitted [ODBC]
- read committed [ODBC]
- serializable reads [ODBC]
- phantoms [ODBC]
- transaction isolation [ODBC]
- repeatable reads [ODBC]
- transactions [ODBC], isolation
ms.assetid: 0d638d55-ffd0-48fb-834b-406f466214d4
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: 63e08aa2e75d560ce73c549d307418432ffe16af
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/15/2019
ms.locfileid: "63149093"
---
# <a name="transaction-isolation-levels"></a>트랜잭션 격리 수준
*트랜잭션 격리 수준* 격리는 트랜잭션에 성공 하는 정도 측정 됩니다. 특히 트랜잭션 격리 수준은 다음 현상의 현재 상태에 따라 정의 됩니다.  
  
-   **더티 읽기** A *커밋되지 않은 읽기* 트랜잭션이 아직 커밋되지 않은 데이터를 읽을 때 발생 합니다. 예를 들어 트랜잭션 1 업데이트를 행 가정 합니다. 트랜잭션 2 트랜잭션 1 업데이트를 커밋하기 전에 업데이트 된 행을 읽습니다. 트랜잭션 1 변경 롤백되면 트랜잭션 2 있었을 적용 되지 않고 간주 되는 데이터를 읽을 됩니다.  
  
-   **읽기가** A *반복 하지 않는 읽기* 하면 트랜잭션이 같은 행을 두 번 읽습니다 될 때마다 다른 데이터를 가져옵니다. 예를 들어 1 트랜잭션 읽기를 행 가정 합니다. 트랜잭션 2 업데이트 하 고 해당 행을 삭제 또는 업데이트 또는 삭제를 커밋합니다. 트랜잭션 1에서는 행을 다시 읽습니다, 다른 행 값을 검색 하거나 행을 삭제 했을 검색 합니다.  
  
-   **팬텀** A *가상* 행 검색 조건과 일치 하는 처음에 표시 되지 않습니다. 예를 들어, 트랜잭션 1 몇 가지 검색 기준을 만족 하는 행 집합을 읽습니다. 트랜잭션 2 트랜잭션 1에 대 한 검색 조건과 일치 하는 업데이트 또는 삽입) (통해 새 행을 생성 합니다. 트랜잭션 1에 행을 읽는 문을 reexecutes, 하는 경우 다른 행 집합을 가져옵니다.  
  
 이러한 현상 (SQL-92에 의해 정의 됨) 처럼 4 개의 트랜잭션 격리 수준에 정의 됩니다. 다음 표에서 "X"가 발생할 수 있는 각 현상을 표시 합니다.  
  
|트랜잭션 격리 수준|커밋되지 않은 읽기|반복 되지 않는 읽기|가상|  
|---------------------------------|-----------------|-------------------------|--------------|  
|커밋되지 않은 읽기|X|X|X|  
|커밋된 읽기|--|X|X|  
|반복 읽기|--|--|X|  
|직렬화 가능|--|--|--|  
  
 다음 표에서 DBMS 트랜잭션 격리 수준은 구현할 수 있습니다 하는 간단한 방법을 설명 합니다.  
  
> [!IMPORTANT]  
>  대부분의 Dbms 이러한 보다 더 복잡 한 스키마를 사용 하 여 동시성이 증가. 이러한 예제는 설명 목적 으로만 제공 됩니다. 특히 ODBC Dbms 특정 방법을 규정 하지 않습니다 서로 트랜잭션을 격리 합니다.  
  
|트랜잭션 격리|가능한 구현|  
|---------------------------|-----------------------------|  
|커밋되지 않은 읽기|트랜잭션은 서로 격리 되지 않습니다. DBMS 다른 트랜잭션 격리 수준이 지 원하는 경우에 메커니즘을 사용 하 여 이러한 수준을 구현 하기는 무시 합니다. 부정적인 영향을 주지 않습니다 다른 트랜잭션, Read Uncommitted 수준에서 실행 되는 트랜잭션에서 일반적으로 읽기 전용입니다.|  
|커밋된 읽기|트랜잭션 쓰기 다른 트랜잭션에 의해 잠긴 행; 잠기지 않습니다. 될 때까지 대기 이렇게 변경 된 데이터를 읽을 수 없도록 합니다.<br /><br /> 읽기 잠금 (만 행을 읽고) 하는 경우 또는 쓰기 잠금 다른 트랜잭션의 업데이트 또는 삭제를 방지 하기 위해 현재 행에서 (업데이트 하거나 행을 삭제 하기) 경우 트랜잭션 저장 합니다. 트랜잭션이 현재 행 외부 움직이면 읽기 잠금을 해제 합니다. 커밋되거나 롤백될 때까지 쓰기 잠금을 보유 합니다.|  
|반복 읽기|트랜잭션 쓰기 다른 트랜잭션에 의해 잠긴 행; 잠기지 않습니다. 될 때까지 대기 이렇게 변경 된 데이터를 읽을 수 없도록 합니다.<br /><br /> 트랜잭션 응용 프로그램 및 쓰기 잠금을 삽입, 업데이트 또는 삭제 하는 모든 행을 반환 하는 모든 행에서 읽기 잠금을 보유 합니다. 예를 들어 트랜잭션이 SQL 문을 포함 하는 경우 **선택 \* 에서 주문**, 트랜잭션 읽기 잠금은 행으로 응용 프로그램을 인출 합니다. 트랜잭션이 SQL 문을 포함 하는 경우 **삭제에서 주문 여기서 상태는 '종결' =** , 트랜잭션 쓰기 잠금을 행에 삭제 하는 대로 합니다.<br /><br /> 다른 트랜잭션이 업데이트 하거나 이러한 행을 삭제할 수 없습니다, 때문에 현재 트랜잭션이 모든 읽기가 방지 합니다. 트랜잭션이 커밋되거나 롤백될 때 잠금을 해제 합니다.|  
|직렬화 가능|트랜잭션 쓰기 다른 트랜잭션에 의해 잠긴 행; 잠기지 않습니다. 될 때까지 대기 이렇게 변경 된 데이터를 읽을 수 없도록 합니다.<br /><br /> 트랜잭션 (만 행을 읽고) 하는 경우 읽기 잠금을 보유 또는 해당 범위에서 쓰기 잠금 (업데이트 하거나 행을 삭제) 경우에 영향을 줍니다를 제공 하는 행입니다. 예를 들어 트랜잭션이 SQL 문을 포함 하는 경우 **선택 \* 에서 주문**, 범위는 전체 Orders 테이블; 트랜잭션 읽기-잠금은 테이블과 새 행을 삽입할 수 없습니다. 트랜잭션이 SQL 문을 포함 하는 경우 **삭제에서 주문 여기서 상태는 '종결' =** , 범위 "CLOSED"의 상태를 사용 하 여 모든 행은 트랜잭션 쓰기 잠금의 주문의 모든 행 테이블 "CLOSED" 및 상태의 없습니다 모든 행을 삽입 하거나 업데이트 결과 행 "CLOSED" 상태가 되도록 허용 합니다.<br /><br /> 다른 트랜잭션이 업데이트 하거나 범위에서 행을 삭제할 수 없습니다, 때문에 현재 트랜잭션이 모든 읽기가 방지 합니다. 다른 트랜잭션 범위에서 모든 행을 삽입할 수 없습니다, 때문에 현재 트랜잭션이 모든 가상 피할 수 있습니다. 트랜잭션이 커밋되거나 롤백될 때 잠금을 해제 합니다.|  
  
 트랜잭션 격리 수준 트랜잭션이 자체 변경; 참조 수 영향을 주지 않습니다 해야 트랜잭션이 변경 내용을 항상 볼 수 있습니다. 트랜잭션 2의 구성 될 수 있습니다 예를 들어 **업데이트** 첫 번째는 모든 직원의 급여를 10% 씩 시키고 두 번째는 해당 크기를 최대 몇 시간 동안 모든 직원의 급여를 설정 하십시오. 때문에 단일 트랜잭션으로 성공 하는이 두 번째 **업데이트** 문을 첫 번째 결과 볼 수 있습니다.
